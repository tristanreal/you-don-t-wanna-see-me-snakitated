// this is malware hehe ;) only real men will paste it in their browser ;)
let canvas = document.createElement("canvas");
canvas.width = 400;
canvas.height = 400;
canvas.style.position = "fixed";
canvas.style.top = "50%";
canvas.style.left = "50%";
canvas.style.transform = "translate(-50%, -50%)";
canvas.style.border = "2px solid #000";
canvas.style.zIndex = "9999";
document.body.appendChild(canvas);
let ctx = canvas.getContext("2d");

let scoreDisplay = document.createElement("div");
scoreDisplay.style.position = "fixed";
scoreDisplay.style.top = "10px";
scoreDisplay.style.left = "50%";
scoreDisplay.style.transform = "translateX(-50%)";
scoreDisplay.style.fontSize = "24px";
scoreDisplay.style.fontFamily = "Arial, sans-serif";
scoreDisplay.style.color = "black";
scoreDisplay.style.zIndex = "9999";
document.body.appendChild(scoreDisplay);

const blockSize = 20;
const gridSize = canvas.width / blockSize;
let snake = [{ x: 5, y: 5 }];
let direction = { x: 0, y: 0 };
let nextDirection = { x: 0, y: 0 };
let food = spawnFood();
let score = 1;
let gameRunning = true;

document.addEventListener("contextmenu", (e) => e.preventDefault());

function drawGrid() {
  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      ctx.fillStyle = (x + y) % 2 === 0 ? "green" : "red";
      ctx.fillRect(x * blockSize, y * blockSize, blockSize, blockSize);
    }
  }
}

function drawSnake() {
  snake.forEach(segment => {
    ctx.fillStyle = "purple";
    ctx.fillRect(segment.x * blockSize, segment.y * blockSize, blockSize, blockSize);
  });
}

function drawFood() {
  ctx.fillStyle = "gold";
  ctx.fillRect(food.x * blockSize, food.y * blockSize, blockSize, blockSize);
}

function moveSnake() {
  direction = nextDirection;
  let head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };

  if (head.x < 0 || head.x >= gridSize || head.y < 0 || head.y >= gridSize) {
    endGame("lose");
    return;
  }

  snake.unshift(head);

  if (head.x === food.x && head.y === food.y) {
    score++;
    updateScore();
    if (score === 15) {
      endGame("win");
      return;
    }
    food = spawnFood();
  } else {
    snake.pop();
  }
}

function checkCollision() {
  for (let i = 1; i < snake.length; i++) {
    if (snake[i].x === snake[0].x && snake[i].y === snake[0].y) {
      return true;
    }
  }
  return false;
}

function updateScore() {
  scoreDisplay.textContent = `Score: ${score}`;
}

function endGame(result) {
  gameRunning = false;
  document.body.removeChild(canvas);
  document.body.removeChild(scoreDisplay);

  if (result === "win") {
    alert("Congratulations! You reached 15 points and won!");
  } else {
    let blackScreen = document.createElement("div");
    blackScreen.style.position = "fixed";
    blackScreen.style.top = 0;
    blackScreen.style.left = 0;
    blackScreen.style.width = "100%";
    blackScreen.style.height = "100%";
    blackScreen.style.backgroundColor = "black";
    blackScreen.style.zIndex = "99999";
    document.body.appendChild(blackScreen);

    function blockKeys(e) {
      e.preventDefault();
      e.stopImmediatePropagation();
    }

    document.addEventListener("keydown", blockKeys, true);
    document.addEventListener("contextmenu", blockKeys, true);

    setTimeout(() => {
      document.body.removeChild(blackScreen);
      document.removeEventListener("keydown", blockKeys, true);
      document.removeEventListener("contextmenu", blockKeys, true);
    }, 15000);
  }
}

function spawnFood() {
  let x, y;
  do {
    x = Math.floor(Math.random() * (gridSize - 4)) + 2;js
    y = Math.floor(Math.random() * (gridSize - 4)) + 2;
  } while (snake.some(segment => segment.x === x && segment.y === y));
  return { x, y };
}

function gameLoop() {
  if (!gameRunning) return;

  drawGrid();
  moveSnake();
  drawSnake();
  drawFood();

  if (checkCollision()) {
    endGame("lose");
  } else {
    setTimeout(gameLoop, 100);
  }
}

document.addEventListener("keydown", (e) => {
  if ((e.key === "ArrowUp" || e.key === "w") && direction.y === 0) nextDirection = { x: 0, y: -1 };
  if ((e.key === "ArrowDown" || e.key === "s") && direction.y === 0) nextDirection = { x: 0, y: 1 };
  if ((e.key === "ArrowLeft" || e.key === "a") && direction.x === 0) nextDirection = { x: -1, y: 0 };
  if ((e.key === "ArrowRight" || e.key === "d") && direction.x === 0) nextDirection = { x: 1, y: 0 };
});

updateScore();
gameLoop();
